<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHISS - Triangular Chess</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .main-content {
            display: flex;
            gap: 40px;
            align-items: center;
            flex-wrap: wrap;
            min-height: 60vh;
        }
        
        .board-section {
            flex: 1;
            min-width: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .legend-section {
            flex: 0 0 300px;
            min-width: 250px;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin: 0 0 30px 0;
            font-size: 3em;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        .controls {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .toggle-btn {
            padding: 10px 20px;
            font-size: 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.3s;
        }
        
        .toggle-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.15);
        }
        
        .toggle-btn:active {
            transform: translateY(0);
        }
        
        .fullscreen-btn {
            padding: 10px 20px;
            font-size: 16px;
            background: #764ba2;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.3s;
            margin-left: 10px;
        }
        
        .fullscreen-btn:hover {
            background: #5a3a7a;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.15);
        }
        
        .fullscreen-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        .fullscreen-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1001;
        }
        
        .exit-fullscreen {
            padding: 10px 20px;
            font-size: 16px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }
        
        .exit-fullscreen:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
        
        .fullscreen-mode .board {
            position: relative;
            margin: 0;
            transform: rotate(45deg) scale(1.2);
        }
        
        .board {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
            transform: rotate(45deg);
            margin: 50px 0;
            position: relative;
            contain: layout;
        }
        
        .row {
            display: flex;
            gap: 0;
        }
        
        .cell {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            border: 1px solid #333;
            background: #f0d9b5;
            position: relative;
            flex-shrink: 0;
            box-sizing: border-box;
        }
        
        .cell.dark {
            background: #b58863;
        }
        
        .cell:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .cell.selected {
            background: #ffeb3b !important;
            box-shadow: 0 0 15px #ffc107;
            transform: scale(1.05);
        }
        
        .cell.valid-move {
            background: #4caf50 !important;
            box-shadow: 0 0 10px #2e7d32;
        }
        
        .cell.valid-move:hover {
            background: #66bb6a !important;
        }
        
        .cell.capture-move {
            background: #f44336 !important;
            box-shadow: 0 0 10px #c62828;
        }
        
        .cell.capture-move:hover {
            background: #ef5350 !important;
        }
        
        .cell.in-check {
            background: #ff9800 !important;
            box-shadow: 0 0 20px #ff5722;
            animation: checkPulse 1s infinite;
        }
        
        @keyframes checkPulse {
            0%, 100% { box-shadow: 0 0 20px #ff5722; }
            50% { box-shadow: 0 0 30px #ff5722, 0 0 40px #ff5722; }
        }
        
        /* Last move highlighting */
        .cell.last-move-from {
            border: 3px solid #2196f3 !important;
            box-shadow: inset 0 0 10px rgba(33, 150, 243, 0.3);
        }
        
        .cell.last-move-to {
            border: 3px solid #4caf50 !important;
            box-shadow: inset 0 0 10px rgba(76, 175, 80, 0.3);
        }
        
        /* Attack indicators */
        .cell.under-attack {
            border: 2px solid #ff5722 !important;
            box-shadow: inset 0 0 8px rgba(255, 87, 34, 0.4);
        }
        
        /* Possible moves preview dots */
        .cell.preview-move::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            background: rgba(76, 175, 80, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            z-index: 5;
            transition: all 0.2s ease;
        }
        
        .cell.preview-capture::before {
            background: rgba(244, 67, 54, 0.6);
            width: 16px;
            height: 16px;
        }
        
        /* Piece animations - stable positioning to prevent board splitting */
        .cell span:not(.label) {
            position: relative;
            display: inline-block;
        }
        
        .piece-moving {
            position: absolute;
            z-index: 100;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .piece-capturing {
            animation: captureOut 0.4s ease-in-out forwards;
        }
        
        @keyframes captureOut {
            0% { 
                transform: rotate(-45deg) scale(1);
                opacity: 1;
            }
            50% {
                transform: rotate(-45deg) scale(1.2);
                opacity: 0.7;
            }
            100% { 
                transform: rotate(-45deg) scale(0);
                opacity: 0;
            }
        }
        
        /* Enhanced check warning */
        .cell.in-check {
            background: #ff9800 !important;
            border: 3px solid #f44336 !important;
            box-shadow: 0 0 25px #ff5722, inset 0 0 15px rgba(244, 67, 54, 0.3);
            animation: checkPulseEnhanced 0.8s infinite;
        }
        
        @keyframes checkPulseEnhanced {
            0%, 100% { 
                box-shadow: 0 0 25px #ff5722, inset 0 0 15px rgba(244, 67, 54, 0.3);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 35px #ff5722, 0 0 45px #ff5722, inset 0 0 20px rgba(244, 67, 54, 0.5);
                transform: scale(1.02);
            }
        }
        
        /* Turn transition effects */
        .current-player {
            transition: all 0.5s ease-in-out;
        }
        
        .game-status {
            transition: all 0.3s ease-in-out;
        }
        
        .turn-change {
            animation: turnChange 0.6s ease-in-out;
        }
        
        @keyframes turnChange {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* Hover preview effects */
        .cell:hover.preview-move::before {
            width: 16px;
            height: 16px;
            background: rgba(76, 175, 80, 0.8);
        }
        
        .cell:hover.preview-capture::before {
            width: 20px;
            height: 20px;
            background: rgba(244, 67, 54, 0.8);
        }
        
        .label {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px;
            color: #666;
            font-weight: bold;
            transform: rotate(-45deg);
        }
        
        .legend {
            padding: 20px;
            background: #f5f5f5;
            border-radius: 10px;
            height: fit-content;
        }
        
        @media (max-width: 1000px) {
            .main-content {
                flex-direction: column;
                align-items: center;
                min-height: auto;
            }
            
            .board-section {
                min-width: auto;
                width: 100%;
            }
            
            .legend-section {
                flex: none;
                width: 100%;
                max-width: 500px;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2.5em;
                margin-bottom: 20px;
            }
            
            .board {
                margin: 30px 0;
                transform: rotate(45deg) scale(0.8);
            }
            
            .cell {
                width: 50px;
                height: 50px;
            }
            
            .main-content {
                gap: 20px;
            }
            
            .fullscreen-mode .board {
                transform: rotate(45deg) scale(0.9) !important;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 2em;
                letter-spacing: 2px;
            }
            
            .board {
                transform: rotate(45deg) scale(0.7);
                margin: 20px 0;
            }
            
            .cell {
                width: 40px;
                height: 40px;
            }
            
            .toggle-btn, .fullscreen-btn {
                padding: 8px 16px;
                font-size: 14px;
                margin: 5px;
            }
            
            .controls {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }
            
            .legend {
                padding: 15px;
            }
            
            .legend-item {
                font-size: 16px;
            }
            
            .fullscreen-mode .board {
                transform: rotate(45deg) scale(0.78) !important;
            }
            
            .fullscreen-controls {
                top: 10px;
                right: 10px;
            }
            
            .exit-fullscreen {
                padding: 8px 16px;
                font-size: 14px;
            }
        }
        
        .legend h3 {
            margin-top: 0;
            color: #333;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
            font-size: 18px;
        }
        
        .legend-icon {
            font-size: 28px;
            margin-right: 15px;
            width: 40px;
            text-align: center;
        }
        
        .player-section {
            margin: 20px 0;
        }
        
        .player-label {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .game-status {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .current-player {
            font-size: 18px;
            font-weight: bold;
            color: #1976d2;
            margin-bottom: 10px;
        }
        
        .game-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        .game-btn {
            padding: 8px 16px;
            font-size: 14px;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .game-btn:hover {
            background: #1976d2;
            transform: translateY(-1px);
        }
        
        .captures {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
        }
        
        .captures h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .captured-pieces {
            font-size: 20px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CHISS</h1>
        
        <div class="main-content">
            <div class="board-section">
                <div class="board" id="board"></div>
            </div>
            
            <div class="legend-section">
                <div class="game-status">
                    <div class="current-player" id="currentPlayer">White's Turn</div>
                    <div class="game-controls">
                        <button class="game-btn" id="newGameBtn">New Game</button>
                        <button class="game-btn" id="undoBtn">Undo Move</button>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="toggle-btn" id="toggleNumbers">Show Grid Numbers</button>
                    <button class="fullscreen-btn" id="fullscreenBtn">Fullscreen</button>
                </div>
                
                <div class="captures">
                    <h4>Captured Pieces</h4>
                    <div><strong>White captured:</strong> <span id="whiteCaptured" class="captured-pieces"></span></div>
                    <div><strong>Black captured:</strong> <span id="blackCaptured" class="captured-pieces"></span></div>
                </div>
                
                <div class="legend">
            <h3>Piece Legend</h3>
            <div class="player-section">
                <div class="player-label">White Pieces (Bottom)</div>
                <div class="legend-item"><span class="legend-icon">♔</span> King</div>
                <div class="legend-item"><span class="legend-icon">♕</span> Queen</div>
                <div class="legend-item"><span class="legend-icon">♘</span> Knight (Horse)</div>
                <div class="legend-item"><span class="legend-icon">♗</span> Bishop</div>
                <div class="legend-item"><span class="legend-icon">♖</span> Rook</div>
                <div class="legend-item"><span class="legend-icon">♙</span> Pawn</div>
                <div class="legend-item"><span class="legend-icon">⚔</span> Mercenary</div>
            </div>
            <div class="player-section">
                <div class="player-label">Black Pieces (Top)</div>
                <div class="legend-item"><span class="legend-icon">♚</span> King</div>
                <div class="legend-item"><span class="legend-icon">♛</span> Queen</div>
                <div class="legend-item"><span class="legend-icon">♞</span> Knight (Horse)</div>
                <div class="legend-item"><span class="legend-icon">♝</span> Bishop</div>
                <div class="legend-item"><span class="legend-icon">♜</span> Rook</div>
                <div class="legend-item"><span class="legend-icon">♟</span> Pawn</div>
                <div class="legend-item"><span class="legend-icon">⚔</span> Mercenary</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // CHISS Game Implementation
        class ChissGame {
            constructor() {
                this.board = Array(8).fill().map(() => Array(8).fill(null));
                this.currentPlayer = 'white';
                this.selectedCell = null;
                this.gameHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.gameStatus = 'playing'; // 'playing', 'checkmate', 'stalemate'
                this.lastMove = null; // Track last move for highlighting
                this.animationInProgress = false; // Prevent clicks during animations
                
                this.initializePieces();
                this.createBoard();
                this.setupEventListeners();
                this.updateDisplay();
            }
            
            initializePieces() {
                // Black pieces (top-left corner)
                this.board[0][0] = { type: 'king', color: 'black', symbol: '♚' };
                this.board[1][0] = { type: 'knight', color: 'black', symbol: '♞' };
                this.board[0][1] = { type: 'knight', color: 'black', symbol: '♞' };
                this.board[1][1] = { type: 'queen', color: 'black', symbol: '♛' };
                this.board[2][0] = { type: 'bishop', color: 'black', symbol: '♝' };
                this.board[0][2] = { type: 'bishop', color: 'black', symbol: '♝' };
                this.board[3][0] = { type: 'rook', color: 'black', symbol: '♜' };
                this.board[0][3] = { type: 'rook', color: 'black', symbol: '♜' };
                
                // Black Pawns
                this.board[2][1] = { type: 'pawn', color: 'black', symbol: '♟' };
                this.board[1][2] = { type: 'pawn', color: 'black', symbol: '♟' };
                this.board[3][1] = { type: 'pawn', color: 'black', symbol: '♟' };
                this.board[1][3] = { type: 'pawn', color: 'black', symbol: '♟' };
                this.board[2][2] = { type: 'pawn', color: 'black', symbol: '♟' };
                this.board[4][0] = { type: 'pawn', color: 'black', symbol: '♟' };
                this.board[0][4] = { type: 'pawn', color: 'black', symbol: '♟' };
                
                // White pieces (bottom-right corner)
                this.board[7][7] = { type: 'king', color: 'white', symbol: '♔' };
                this.board[6][7] = { type: 'knight', color: 'white', symbol: '♘' };
                this.board[7][6] = { type: 'knight', color: 'white', symbol: '♘' };
                this.board[6][6] = { type: 'queen', color: 'white', symbol: '♕' };
                this.board[5][7] = { type: 'bishop', color: 'white', symbol: '♗' };
                this.board[7][5] = { type: 'bishop', color: 'white', symbol: '♗' };
                this.board[4][7] = { type: 'rook', color: 'white', symbol: '♖' };
                this.board[7][4] = { type: 'rook', color: 'white', symbol: '♖' };
                
                // White Pawns
                this.board[5][6] = { type: 'pawn', color: 'white', symbol: '♙' };
                this.board[6][5] = { type: 'pawn', color: 'white', symbol: '♙' };
                this.board[4][6] = { type: 'pawn', color: 'white', symbol: '♙' };
                this.board[6][4] = { type: 'pawn', color: 'white', symbol: '♙' };
                this.board[5][5] = { type: 'pawn', color: 'white', symbol: '♙' };
                this.board[3][7] = { type: 'pawn', color: 'white', symbol: '♙' };
                this.board[7][3] = { type: 'pawn', color: 'white', symbol: '♙' };
            }
            
            createBoard() {
                const boardElement = document.getElementById('board');
                boardElement.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'row';
                    
                    for (let col = 0; col < 8; col++) {
                        const cell = document.createElement('div');
                        const isDark = (row + col) % 2 === 1;
                        cell.className = `cell ${isDark ? 'dark' : ''}`;
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        const piece = this.board[row][col];
                        if (piece) {
                            const pieceSpan = document.createElement('span');
                            pieceSpan.textContent = piece.symbol;
                            pieceSpan.style.transform = 'rotate(-45deg)';
                            pieceSpan.style.display = 'inline-block';
                            pieceSpan.style.fontSize = '32px';
                            cell.appendChild(pieceSpan);
                        } else {
                            const cellNumber = row * 8 + col;
                            const numSpan = document.createElement('span');
                            numSpan.textContent = cellNumber;
                            numSpan.style.transform = 'rotate(-45deg)';
                            numSpan.style.display = 'none';
                            cell.appendChild(numSpan);
                        }
                        
                        const label = document.createElement('span');
                        label.className = 'label';
                        label.textContent = `[${row},${col}]`;
                        label.style.display = 'none';
                        cell.appendChild(label);
                        
                        cell.addEventListener('click', (e) => this.handleCellClick(row, col));
                        rowDiv.appendChild(cell);
                    }
                    
                    boardElement.appendChild(rowDiv);
                }
            }
            
            handleCellClick(row, col) {
                if (this.gameStatus !== 'playing' || this.animationInProgress) return;
                
                const clickedPiece = this.board[row][col];
                
                if (this.selectedCell) {
                    const [selectedRow, selectedCol] = this.selectedCell;
                    
                    if (selectedRow === row && selectedCol === col) {
                        // Deselect current piece
                        this.clearSelection();
                        return;
                    }
                    
                    if (this.isValidMove(selectedRow, selectedCol, row, col)) {
                        this.makeMoveWithAnimation(selectedRow, selectedCol, row, col);
                    } else {
                        // Select new piece if it belongs to current player
                        if (clickedPiece && clickedPiece.color === this.currentPlayer) {
                            this.selectCell(row, col);
                        } else {
                            this.clearSelection();
                        }
                    }
                } else {
                    // Select piece if it belongs to current player
                    if (clickedPiece && clickedPiece.color === this.currentPlayer) {
                        this.selectCell(row, col);
                    }
                }
            }
            
            selectCell(row, col) {
                this.clearSelection();
                this.selectedCell = [row, col];
                
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                cell.classList.add('selected');
                
                // Highlight valid moves
                this.highlightValidMoves(row, col);
            }
            
            clearSelection() {
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('selected', 'valid-move', 'capture-move');
                });
                this.selectedCell = null;
            }
            
            clearAllHighlights() {
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('selected', 'valid-move', 'capture-move', 'preview-move', 'preview-capture', 'under-attack', 'last-move-from', 'last-move-to');
                });
            }
            
            highlightValidMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return;
                
                // Clear any existing preview dots
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('preview-move', 'preview-capture');
                });
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (this.isValidMove(row, col, r, c)) {
                            const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                            if (this.board[r][c] && this.board[r][c].color !== piece.color) {
                                cell.classList.add('capture-move');
                                cell.classList.add('preview-capture');
                            } else {
                                cell.classList.add('valid-move');
                                cell.classList.add('preview-move');
                            }
                        }
                    }
                }
            }
            
            isValidMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const targetPiece = this.board[toRow][toCol];
                
                if (!piece) return false;
                if (piece.color !== this.currentPlayer) return false;
                if (targetPiece && targetPiece.color === piece.color) return false;
                if (fromRow === toRow && fromCol === toCol) return false;
                
                // Check basic piece movement rules
                if (!this.isValidPieceMove(fromRow, fromCol, toRow, toCol)) {
                    return false;
                }
                
                // Check if this move would leave the king in check
                return !this.wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol);
            }
            
            isValidPieceMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                
                switch (piece.type) {
                    case 'pawn':
                        return this.isValidPawnMove(fromRow, fromCol, toRow, toCol, piece.color);
                    case 'rook':
                        return (rowDiff === 0 || colDiff === 0) && this.isPathClear(fromRow, fromCol, toRow, toCol);
                    case 'bishop':
                        return rowDiff === colDiff && this.isPathClear(fromRow, fromCol, toRow, toCol);
                    case 'queen':
                        return (rowDiff === 0 || colDiff === 0 || rowDiff === colDiff) && this.isPathClear(fromRow, fromCol, toRow, toCol);
                    case 'knight':
                        return this.isValidKnightMove(fromRow, fromCol, toRow, toCol);
                    case 'king':
                        return rowDiff <= 1 && colDiff <= 1;
                    default:
                        return false;
                }
            }
            
            wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol) {
                // Make a temporary move
                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];
                
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;
                
                // Check if king is in check after this move
                const kingInCheck = this.isKingInCheck(piece.color);
                
                // Restore the board
                this.board[fromRow][fromCol] = piece;
                this.board[toRow][toCol] = capturedPiece;
                
                return kingInCheck;
            }
            
            isKingInCheck(color) {
                const kingPos = this.findKing(color);
                if (!kingPos) return false;
                
                const [kingRow, kingCol] = kingPos;
                const opponentColor = color === 'white' ? 'black' : 'white';
                
                // Check if any opponent piece can attack the king
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.color === opponentColor) {
                            if (this.isValidPieceMove(row, col, kingRow, kingCol)) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            getAllLegalMoves(color) {
                const legalMoves = [];
                
                for (let fromRow = 0; fromRow < 8; fromRow++) {
                    for (let fromCol = 0; fromCol < 8; fromCol++) {
                        const piece = this.board[fromRow][fromCol];
                        if (piece && piece.color === color) {
                            for (let toRow = 0; toRow < 8; toRow++) {
                                for (let toCol = 0; toCol < 8; toCol++) {
                                    if (this.isValidMove(fromRow, fromCol, toRow, toCol)) {
                                        legalMoves.push({ from: [fromRow, fromCol], to: [toRow, toCol] });
                                    }
                                }
                            }
                        }
                    }
                }
                
                return legalMoves;
            }
            
            isValidPawnMove(fromRow, fromCol, toRow, toCol, color) {
                const rowDiff = toRow - fromRow;
                const colDiff = toCol - fromCol;
                const absRowDiff = Math.abs(rowDiff);
                const absColDiff = Math.abs(colDiff);
                
                // Must move exactly one square
                if (absRowDiff > 1 || absColDiff > 1 || (absRowDiff === 0 && absColDiff === 0)) {
                    return false;
                }
                
                // Calculate distance from target corners
                const currentDistanceToTarget = color === 'white' ? 
                    (fromRow + fromCol) : // White moves toward (0,0)
                    ((7 - fromRow) + (7 - fromCol)); // Black moves toward (7,7)
                    
                const newDistanceToTarget = color === 'white' ? 
                    (toRow + toCol) : // White moves toward (0,0)
                    ((7 - toRow) + (7 - toCol)); // Black moves toward (7,7)
                
                // Cannot move backward (away from target)
                if (newDistanceToTarget > currentDistanceToTarget) {
                    return false;
                }
                
                // Cannot move sideways (same distance from target)
                if (newDistanceToTarget === currentDistanceToTarget) {
                    return false;
                }
                
                // Check if there's a piece to capture
                const targetPiece = this.board[toRow][toCol];
                if (targetPiece) {
                    // Cannot capture pieces on the same tile color
                    const fromTileColor = (fromRow + fromCol) % 2;
                    const toTileColor = (toRow + toCol) % 2;
                    
                    if (fromTileColor === toTileColor) {
                        return false; // Cannot capture pieces on same colored tiles
                    }
                }
                
                // Can only move forward or diagonally forward (closer to target)
                return true;
            }
            
            isPathClear(fromRow, fromCol, toRow, toCol) {
                const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
                const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
                
                let currentRow = fromRow + rowStep;
                let currentCol = fromCol + colStep;
                
                while (currentRow !== toRow || currentCol !== toCol) {
                    if (this.board[currentRow][currentCol]) {
                        return false;
                    }
                    currentRow += rowStep;
                    currentCol += colStep;
                }
                
                return true;
            }
            
            isValidKnightMove(fromRow, fromCol, toRow, toCol) {
                const rowDiff = Math.abs(toRow - fromRow);
                const colDiff = Math.abs(toCol - fromCol);
                
                // Cannot stay in same position
                if (rowDiff === 0 && colDiff === 0) return false;
                
                // Must be a straight line move (horizontal, vertical, or diagonal)
                const isHorizontal = (rowDiff === 0 && colDiff > 0);
                const isVertical = (colDiff === 0 && rowDiff > 0);
                const isDiagonal = (rowDiff === colDiff && rowDiff > 0);
                
                if (!isHorizontal && !isVertical && !isDiagonal) {
                    return false;
                }
                
                // Must complete exactly 3 steps; jumping over pieces is allowed
                const steps = Math.max(rowDiff, colDiff);
                return steps === 2;
            }
            
            isKnightPathClear(fromRow, fromCol, toRow, toCol) {
                const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
                const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
                
                let currentRow = fromRow + rowStep;
                let currentCol = fromCol + colStep;
                
                // Check path excluding the destination square (knight can capture at destination)
                while (currentRow !== toRow || currentCol !== toCol) {
                    if (this.board[currentRow][currentCol]) {
                        return false;
                    }
                    currentRow += rowStep;
                    currentCol += colStep;
                }
                
                return true;
            }
            
            makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];
                
                // Record move for history
                this.gameHistory.push({
                    from: [fromRow, fromCol],
                    to: [toRow, toCol],
                    piece: { ...piece },
                    captured: capturedPiece ? { ...capturedPiece } : null
                });
                
                // Handle capture
                if (capturedPiece) {
                    this.capturedPieces[capturedPiece.color].push(capturedPiece);
                }
                
                // Track last move for highlighting
                this.lastMove = { from: [fromRow, fromCol], to: [toRow, toCol] };
                
                // Move piece
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;
                
                this.createBoard();
            }
            
            async makeMoveWithAnimation(fromRow, fromCol, toRow, toCol) {
                this.animationInProgress = true;
                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];
                
                // Clear all highlights
                this.clearAllHighlights();
                
                // Handle capture animation
                if (capturedPiece) {
                    const targetCell = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
                    const capturedElement = targetCell.querySelector('span:not(.label)');
                    if (capturedElement) {
                        capturedElement.classList.add('piece-capturing');
                        await this.delay(200);
                    }
                }
                
                // Animate piece movement
                await this.animatePieceMovement(fromRow, fromCol, toRow, toCol);
                
                // Make the actual move
                this.makeMove(fromRow, fromCol, toRow, toCol);
                
                // Clear selection and update displays
                this.clearSelection();
                this.highlightLastMove();
                this.showAttackIndicators();
                
                // Switch player with animation
                this.switchPlayerWithAnimation();
                this.updateDisplay();
                this.checkGameEnd();
                
                this.animationInProgress = false;
            }
            
            async animatePieceMovement(fromRow, fromCol, toRow, toCol) {
                const fromCell = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"]`);
                const toCell = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
                const pieceElement = fromCell.querySelector('span:not(.label)');
                
                if (!pieceElement) return;
                
                // Get positions
                const fromRect = fromCell.getBoundingClientRect();
                const toRect = toCell.getBoundingClientRect();
                
                // Create moving piece
                const movingPiece = pieceElement.cloneNode(true);
                movingPiece.className = 'piece-moving';
                movingPiece.style.position = 'fixed';
                movingPiece.style.left = fromRect.left + fromRect.width / 2 - 16 + 'px';
                movingPiece.style.top = fromRect.top + fromRect.height / 2 - 16 + 'px';
                movingPiece.style.fontSize = '32px';
                movingPiece.style.transform = 'none';
                
                document.body.appendChild(movingPiece);
                
                // Hide original piece
                pieceElement.style.opacity = '0';
                
                // Animate to target
                await this.delay(50);
                movingPiece.style.left = toRect.left + toRect.width / 2 - 16 + 'px';
                movingPiece.style.top = toRect.top + toRect.height / 2 - 16 + 'px';
                
                // Wait for animation to complete
                await this.delay(400);
                
                // Clean up
                document.body.removeChild(movingPiece);
                pieceElement.style.opacity = '1';
            }
            
            highlightLastMove() {
                if (!this.lastMove) return;
                
                const fromCell = document.querySelector(`[data-row="${this.lastMove.from[0]}"][data-col="${this.lastMove.from[1]}"]`);
                const toCell = document.querySelector(`[data-row="${this.lastMove.to[0]}"][data-col="${this.lastMove.to[1]}"]`);
                
                if (fromCell) fromCell.classList.add('last-move-from');
                if (toCell) toCell.classList.add('last-move-to');
            }
            
            showAttackIndicators() {
                // Clear existing attack indicators
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('under-attack');
                });
                
                // Show pieces under attack
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.color === this.currentPlayer) {
                            if (this.isPieceUnderAttack(row, col)) {
                                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                                cell.classList.add('under-attack');
                            }
                        }
                    }
                }
            }
            
            isPieceUnderAttack(row, col) {
                const piece = this.board[row][col];
                if (!piece) return false;
                
                const opponentColor = piece.color === 'white' ? 'black' : 'white';
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const attackingPiece = this.board[r][c];
                        if (attackingPiece && attackingPiece.color === opponentColor) {
                            if (this.isValidPieceMove(r, c, row, col)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            
            switchPlayerWithAnimation() {
                const statusElement = document.getElementById('currentPlayer');
                statusElement.classList.add('turn-change');
                
                setTimeout(() => {
                    statusElement.classList.remove('turn-change');
                }, 600);
                
                this.switchPlayer();
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            switchPlayer() {
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
            }
            
            updateDisplay() {
                if (this.gameStatus === 'playing') {
                    document.getElementById('currentPlayer').textContent = 
                        `${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)}'s Turn`;
                    document.getElementById('currentPlayer').style.color = '#1976d2';
                }
                
                const whiteCapturedText = this.capturedPieces.white.map(p => p.symbol).join(' ');
                const blackCapturedText = this.capturedPieces.black.map(p => p.symbol).join(' ');
                
                document.getElementById('whiteCaptured').textContent = whiteCapturedText;
                document.getElementById('blackCaptured').textContent = blackCapturedText;
                
                // Update fullscreen display if active
                const fullscreenPlayer = document.getElementById('fullscreenCurrentPlayer');
                const fullscreenWhite = document.getElementById('fullscreenWhiteCaptured');
                const fullscreenBlack = document.getElementById('fullscreenBlackCaptured');
                
                if (fullscreenPlayer) {
                    fullscreenPlayer.textContent = document.getElementById('currentPlayer').textContent;
                    fullscreenPlayer.style.color = document.getElementById('currentPlayer').style.color;
                }
                if (fullscreenWhite) fullscreenWhite.textContent = whiteCapturedText;
                if (fullscreenBlack) fullscreenBlack.textContent = blackCapturedText;
            }
            
            checkGameEnd() {
                // Check for king capture first
                const whiteKing = this.findKing('white');
                const blackKing = this.findKing('black');
                
                if (!whiteKing) {
                    this.gameStatus = 'checkmate';
                    document.getElementById('currentPlayer').textContent = 'Black Wins! (King Captured)';
                    return;
                } else if (!blackKing) {
                    this.gameStatus = 'checkmate';
                    document.getElementById('currentPlayer').textContent = 'White Wins! (King Captured)';
                    return;
                }
                
                // Check for checkmate or stalemate
                const legalMoves = this.getAllLegalMoves(this.currentPlayer);
                const kingInCheck = this.isKingInCheck(this.currentPlayer);
                
                if (legalMoves.length === 0) {
                    if (kingInCheck) {
                        this.gameStatus = 'checkmate';
                        const winner = this.currentPlayer === 'white' ? 'Black' : 'White';
                        document.getElementById('currentPlayer').textContent = `${winner} Wins! (Checkmate)`;
                    } else {
                        this.gameStatus = 'stalemate';
                        document.getElementById('currentPlayer').textContent = 'Stalemate! (Draw)';
                    }
                } else if (kingInCheck) {
                    // King is in check but has legal moves
                    const playerName = this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1);
                    document.getElementById('currentPlayer').textContent = `${playerName} in Check!`;
                    document.getElementById('currentPlayer').style.color = '#f44336';
                    
                    // Highlight the king in check
                    this.highlightKingInCheck();
                } else {
                    // Normal turn
                    document.getElementById('currentPlayer').style.color = '#1976d2';
                    this.clearCheckHighlight();
                }
            }
            
            highlightKingInCheck() {
                const kingPos = this.findKing(this.currentPlayer);
                if (kingPos) {
                    const [row, col] = kingPos;
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    cell.classList.add('in-check');
                }
            }
            
            clearCheckHighlight() {
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('in-check');
                });
            }
            
            findKing(color) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.type === 'king' && piece.color === color) {
                            return [row, col];
                        }
                    }
                }
                return null;
            }
            
            newGame() {
                this.board = Array(8).fill().map(() => Array(8).fill(null));
                this.currentPlayer = 'white';
                this.selectedCell = null;
                this.gameHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.gameStatus = 'playing';
                this.lastMove = null;
                this.animationInProgress = false;
                
                this.initializePieces();
                this.createBoard();
                this.updateDisplay();
                this.clearCheckHighlight();
                this.clearAllHighlights();
                this.showAttackIndicators();
            }
            
            undoMove() {
                if (this.gameHistory.length === 0) return;
                
                const lastMove = this.gameHistory.pop();
                const { from, to, piece, captured } = lastMove;
                
                // Restore piece to original position
                this.board[from[0]][from[1]] = piece;
                this.board[to[0]][to[1]] = captured;
                
                // Restore captured piece
                if (captured) {
                    const capturedArray = this.capturedPieces[captured.color];
                    const index = capturedArray.findIndex(p => p.symbol === captured.symbol);
                    if (index !== -1) {
                        capturedArray.splice(index, 1);
                    }
                }
                
                // Update last move tracking
                this.lastMove = this.gameHistory.length > 0 ? 
                    { from: this.gameHistory[this.gameHistory.length - 1].from, 
                      to: this.gameHistory[this.gameHistory.length - 1].to } : null;
                
                this.switchPlayer();
                this.createBoard();
                this.updateDisplay();
                this.clearSelection();
                this.clearAllHighlights();
                this.highlightLastMove();
                this.showAttackIndicators();
            }
            
            setupEventListeners() {
                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('undoBtn').addEventListener('click', () => this.undoMove());
                
                // Toggle grid numbers
                const toggleBtn = document.getElementById('toggleNumbers');
                let numbersVisible = false;
                
                toggleBtn.addEventListener('click', () => {
                    numbersVisible = !numbersVisible;
                    
                    document.querySelectorAll('.cell span:not(.label)').forEach(span => {
                        if (span.textContent.match(/^\d+$/)) {
                            span.style.display = numbersVisible ? 'inline-block' : 'none';
                        }
                    });
                    
                    document.querySelectorAll('.label').forEach(label => {
                        label.style.display = numbersVisible ? 'block' : 'none';
                    });
                    
                    toggleBtn.textContent = numbersVisible ? 'Hide Grid Numbers' : 'Show Grid Numbers';
                });
                
                // Fullscreen functionality
                const fullscreenBtn = document.getElementById('fullscreenBtn');
                let isFullscreen = false;
                
                fullscreenBtn.addEventListener('click', () => {
                    if (!isFullscreen) {
                        this.enterFullscreen();
                        isFullscreen = true;
                    }
                });
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && isFullscreen) {
                        this.exitFullscreen();
                        isFullscreen = false;
                    }
                });
            }
            
            enterFullscreen() {
                const fullscreenDiv = document.createElement('div');
                fullscreenDiv.className = 'fullscreen-mode';
                fullscreenDiv.id = 'fullscreenMode';
                
                // Enhanced controls with convenience buttons
                const exitControls = document.createElement('div');
                exitControls.className = 'fullscreen-controls';
                
                // Exit button
                const exitBtn = document.createElement('button');
                exitBtn.className = 'exit-fullscreen';
                exitBtn.textContent = 'Exit Fullscreen';
                exitBtn.onclick = () => this.exitFullscreen();
                
                // New Game button
                const newGameBtn = document.createElement('button');
                newGameBtn.className = 'exit-fullscreen';
                newGameBtn.textContent = 'New Game';
                newGameBtn.style.marginLeft = '10px';
                newGameBtn.onclick = () => this.newGame();
                
                // Undo button
                const undoBtn = document.createElement('button');
                undoBtn.className = 'exit-fullscreen';
                undoBtn.textContent = 'Undo';
                undoBtn.style.marginLeft = '10px';
                undoBtn.onclick = () => this.undoMove();
                
                // Toggle numbers button
                const toggleBtn = document.createElement('button');
                toggleBtn.className = 'exit-fullscreen';
                toggleBtn.textContent = 'Toggle Grid';
                toggleBtn.style.marginLeft = '10px';
                toggleBtn.onclick = () => {
                    const numbersVisible = document.querySelector('.label').style.display !== 'none';
                    document.querySelectorAll('.cell span:not(.label)').forEach(span => {
                        if (span.textContent.match(/^\d+$/)) {
                            span.style.display = !numbersVisible ? 'inline-block' : 'none';
                        }
                    });
                    document.querySelectorAll('.label').forEach(label => {
                        label.style.display = !numbersVisible ? 'block' : 'none';
                    });
                };
                
                exitControls.appendChild(exitBtn);
                exitControls.appendChild(newGameBtn);
                exitControls.appendChild(undoBtn);
                exitControls.appendChild(toggleBtn);
                
                // Game status in fullscreen
                const statusDiv = document.createElement('div');
                statusDiv.style.position = 'absolute';
                statusDiv.style.top = '70px';
                statusDiv.style.right = '20px';
                statusDiv.style.color = 'white';
                statusDiv.style.fontSize = '18px';
                statusDiv.style.fontWeight = 'bold';
                statusDiv.style.textAlign = 'center';
                statusDiv.style.background = 'rgba(0,0,0,0.3)';
                statusDiv.style.padding = '10px';
                statusDiv.style.borderRadius = '8px';
                statusDiv.innerHTML = `
                    <div id="fullscreenCurrentPlayer">${document.getElementById('currentPlayer').textContent}</div>
                    <div style="margin-top: 10px; font-size: 14px;">
                        <div>White captured: <span id="fullscreenWhiteCaptured">${document.getElementById('whiteCaptured').textContent}</span></div>
                        <div>Black captured: <span id="fullscreenBlackCaptured">${document.getElementById('blackCaptured').textContent}</span></div>
                    </div>
                `;
                
                const boardClone = document.getElementById('board').cloneNode(true);
                boardClone.id = 'fullscreenBoard';
                
                fullscreenDiv.appendChild(exitControls);
                fullscreenDiv.appendChild(statusDiv);
                fullscreenDiv.appendChild(boardClone);
                document.body.appendChild(fullscreenDiv);
                
                // Copy event listeners to fullscreen board
                this.setupFullscreenEventListeners(boardClone);
            }
            
            setupFullscreenEventListeners(boardClone) {
                const cells = boardClone.querySelectorAll('.cell');
                cells.forEach(cell => {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    cell.addEventListener('click', (e) => this.handleCellClick(row, col));
                });
            }
            
            exitFullscreen() {
                const fullscreenDiv = document.getElementById('fullscreenMode');
                if (fullscreenDiv) {
                    document.body.removeChild(fullscreenDiv);
                }
            }
        }
        
        // Initialize the game
        const game = new ChissGame();
    </script>
</body>
</html>
